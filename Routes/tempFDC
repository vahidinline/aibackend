 const express = require('express');
const router = express.Router();
const { VertexAI } = require('@google-cloud/vertexai');
const Key = require('../config/key.json');
const axios = require('axios');
const APIKEY = process.env.FOOD_DATA_API;

// Initialize VertexAI with your project and location
const vertex_ai = new VertexAI({
  project: 'fitlinez-backend',
  location: 'us-central1',
  keyFilename: '../config/key.json',
});

// Model name and generation configuration
const model = 'gemini-1.5-pro-preview-0409'; // Update with desired model
const generationConfig = {
  maxOutputTokens: 8192,
  temperature: 1,
  topP: 0.95,
};

// Safety settings
const safetySettings = [
  {
    category: 'HARM_CATEGORY_HATE_SPEECH',
    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
  },
  {
    category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
  },
  {
    category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
  },
  { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
];

// Instantiate the generative model
const generativeModel = vertex_ai.preview.getGenerativeModel({
  model,
  generationConfig,
  safetySettings,
});

async function analyzeFood(text) {
  const req = {
    contents: [{ role: 'user', parts: [{ text }] }],
  };
  const response = await generativeModel.generateContent(req);
  const content = response[0].response.candidates[0].content;

  try {
    // Attempt to parse the response as JSON
    const jsonData = JSON.parse(content.parts[0].text);
    return jsonData;
  } catch (error) {
    console.error('Error parsing JSON:', error);
    return { error: 'Invalid JSON response from model' };
  }
}

router.post('/getNutritionFacts', async (req, res) => {
  console.log('Request body:', req.body);
  try {
    const foodItems = req.body.name;
    console.log('Food items:', foodItems);
    let nutritionFacts = [];

    // Iterate through each item in foodItems
    // for (const item of foodItems) {
    const response = await axios.get(
      `https://api.nal.usda.gov/fdc/v1/foods/search?query=${foodItems}&dataType=Branded&pageSize=1&requireAllWords=true&api_key=${APIKEY}`
    );
    console.log(response.data);
    if (
      response.data &&
      response.data.foods &&
      response.data.foods.length > 0
    ) {
      const foodData = response.data.foods[0];
      const servingSizeFromAPI = foodData.servingSize;
      const servingSizeUnitFromAPI = foodData.servingSizeUnit;

      // Extract relevant nutrition information
      const nutrients = foodData.foodNutrients.reduce((acc, nutrient) => {
        // Customize this list based on your desired nutrients
        const targetNutrients = [
          'Energy',
          'Protein',
          'Total lipid (fat)',
          'Carbohydrate, by difference',
          'Fiber, total dietary',
          'Sugars, total including NLEA',
        ];
        if (targetNutrients.includes(nutrient.nutrientName)) {
          acc[nutrient.nutrientName] = `${nutrient.value} ${nutrient.unitName}`;
        }
        return acc;
      }, {});

      nutritionFacts.push({
        name: item.name,
        servingSize: servingSizeFromAPI,
        servingSizeUnit: servingSizeUnitFromAPI,
        nutrition: nutrients,
      });
    } else {
      console.error('No foods data in the response for item:', item);
    }
    //}
    res.json(nutritionFacts);
  } catch (error) {
    console.error(error);
    res.status(500).send(error);
  }
});

router.post('/', async (req, res) => {
  const text = req.body.text; // Assuming text is sent in the request body

  if (!text) {
    return res.status(400).send('Missing text input');
  }

  try {
    const result = await analyzeFood(text);
    res.json(result);
  } catch (error) {
    console.error('Error processing request:', error);
    res.status(500).send('An error occurred');
  }
});

module.exports = router;
